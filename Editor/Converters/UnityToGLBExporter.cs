#if UNITY_EDITOR
using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using UnityEditor;
using UnityEngine;

namespace VoyageVoyage
{
    /**
       Utility class for exporting a single MeshRenderer as a GLB object
       compatible with my VRChat 3D Model Loader.
       This is mainly oriented towards exporting MeshRenderer generated
       by ShaderMotion "CreatePlayer" functionnality.
       This re-encodes the texture, and also encodes ShaderMotion
       material data as a custom extension.
       This can also deal with MToon 1.0 materials to an extent limited
       to what the 3D Model Loader needs.
       
       It is half vibe-coded, half hand-written.
       Originally, the idea was to add a MeshRenderer generated by
       ShaderMotion to a VRM file but it was then reduced to a GLB
       generator, since appending was deemed useless for its use case.
     */
    public class UnityToGLBExporter
    {
        // F T l g
        private const uint GLTF_HEADER_MAGIC = 0x46546C67u;
        // N S O J
        private const uint GLTF_JSON_SECTION_HEADER_MAGIC = 0x4E4F534Au;
        // \0 N I B
        private const uint GLTF_BIN_SECTION_HEADER_MAGIC = 0x004E4942u;
        private const int GLTF_FLOAT_FORMAT = 5126;
        private const int GLTF_ARRAY_BUFFER = 34962;
        private const int GLTF_ELEMENT_ARRAY_BUFFER = 34963;

        private const string shaderMotionGltfExtensionName = "EXT_voyage_shadermotion";
        private const string vrmcMtoonExtensionName = "VRMC_materials_mtoon";
        private const string voyageExporterExtensionName = "EXT_voyage_exporter";

        enum ShaderVarType
        {
            Float,
            Texture,
            Color,
            Bool,
            FloatEnum,
            Int
        };

        class GltfToShaderProperty
        {
            public string gltfName;
            public string unityName;
            public ShaderVarType valueType;
            public string[] enumValues;

            public GltfToShaderProperty(string unity, ShaderVarType valType, string gltf, string[] newEnumValues = null)
            {
                gltfName = gltf;
                unityName = unity;
                valueType = valType;
                enumValues = newEnumValues;
            }
        }
        class GltfContext
        {
            public List<object> textures;
            public List<object> images;
            public List<byte> binaryData;
            public List<object> bufferViews;
        }
        public struct AddedBuffer
        {
            public int index;
            public int byteOffset;
            public int byteLength;
        };

        static GltfToShaderProperty[] standardProperties =
        {
        new("_BumpMap", ShaderVarType.Texture, "normalTexture"),
        new("_EmissionMap", ShaderVarType.Texture, "emissiveTexture"),
        new("_EmissionColor", ShaderVarType.Color, "emissiveFactor"),
        new("_AlphaMode", ShaderVarType.FloatEnum, "alphaMode", new string[] { "OPAQUE", "MASK", "BLEND" }),
        new("_Cutoff", ShaderVarType.Int, "alphaCutOff"),
        new("_DoubleSided", ShaderVarType.Bool, "doubleSided")
    };

        static GltfToShaderProperty[] standardPbrProperties =
        {
        new("_MainTex", ShaderVarType.Texture, "baseColorTexture"),
        new("_Color", ShaderVarType.Color, "baseColorFactor"),

    };

        static GltfToShaderProperty[] mToonProperties =
        {
        new("_TransparentWithZWrite", ShaderVarType.Bool, "transparentWithZWrite"),
        new("_RenderQueueOffset" , ShaderVarType.Float, "renderQueueOffsetNumber"),
        new("_ShadeColor" , ShaderVarType.Color, "shadeColorFactor"),
        new("_ShadeTex" , ShaderVarType.Texture, "shadeMultiplyTexture"),
        new("_ShadingShiftFactor" , ShaderVarType.Float, "shadingShiftFactor"),
        new("_ShadingToonyFactor" , ShaderVarType.Float, "shadingToonyFactor"),
        new("_GiEqualization" , ShaderVarType.Float, "giEqualizationFactor"),
        new("_MatcapColor" , ShaderVarType.Color, "matcapFactor"),
        new("_MatcapTex" , ShaderVarType.Texture, "matcapTexture"),
        new("_RimColor" , ShaderVarType.Color, "parametricRimColorFactor"),
        new("_RimTex" , ShaderVarType.Texture, "rimMultiplyTexture"),
        new("_RimLightingMix" , ShaderVarType.Float, "rimLightingMixFactor"),
        new("_RimFresnelPower" , ShaderVarType.Float, "parametricRimFresnelPowerFactor"),
        new("_RimLift" , ShaderVarType.Float, "parametricRimLiftFactor"),
        new("_OutlineWidthMode" , ShaderVarType.FloatEnum, "outlineWidthMode", new string[] { "none", "worldCoordinates", "screenCoordinates" }),
        new("_OutlineWidth" , ShaderVarType.Float, "outlineWidthFactor"),
        new("_OutlineWidthTex" , ShaderVarType.Texture, "outlineWidthMultiplyTexture"),
        new("_OutlineColor" , ShaderVarType.Color, "outlineColorFactor"),
        new("_OutlineLightingMix" , ShaderVarType.Float, "outlineLightingMixFactor"),
        new("_UvAnimMaskTex" , ShaderVarType.Texture, "uvAnimationMaskTexture"),
        new("_UvAnimScrollXSpeed" , ShaderVarType.Float, "uvAnimationScrollXSpeedFactor"),
        new("_UvAnimScrollYSpeed" , ShaderVarType.Float, "uvAnimationScrollYSpeedFactor"),
        new("_UvAnimRotationSpeed" , ShaderVarType.Float, "uvAnimationRotationSpeedFactor")
    };

        static GltfToShaderProperty[] shaderMotionProperties =
        {
        new("_Bone", ShaderVarType.Texture, "boneTexture"),
        new("_Shape", ShaderVarType.Texture, "shapeTexture"),
        new("_HumanScale", ShaderVarType.Float, "humanScale"),
        new("_Layer", ShaderVarType.Float, "layer"),
        new("_RotationTolerance", ShaderVarType.Float, "rotationTolerance"),
    };

        public static void ExportMeshRendererToGLB(MeshRenderer renderer, string path)
        {
            if (renderer == null || path == null || path.Trim().Length == 0)
            {
                Debug.LogError("Missing either the renderer or the save path");
                return;
            }

            // Read and parse the original GLB
            //RecurseDeserialize(gltfDict);

            Dictionary<string, object> gltfDict = new();
            List<byte> binaryData = new List<byte>();
            Debug.Log(gltfDict.GetType());
            // Append new data to GLB
            AppendMeshDataToGLTF(gltfDict, ref binaryData, renderer);

            // Write the modified GLB
            WriteGLB(path, gltfDict, binaryData);

            EditorUtility.DisplayDialog("Success", "Mesh successfully appended to GLB file!", "OK");
            AssetDatabase.Refresh();


        }

        static private int AppendMeshDataToGLTF(Dictionary<string, object> gltfObject, ref List<byte> binaryData, MeshRenderer meshRenderer)
        {
            Mesh mesh = meshRenderer.GetComponent<MeshFilter>().sharedMesh;

            List<object> buffers = new();
            List<object> bufferViews = new();
            List<object> accessors = new();
            List<object> meshes = new();
            List<object> materials = new();
            List<object> textures = new();
            List<object> images = new();
            List<object> nodes = new();
            List<object> scenes = new();

            gltfObject["asset"] = new Dictionary<string, object>()
            {
                ["version"] = "2.0",
                ["generator"] = "Voyage ShaderMotion MeshPlayer to GLB"
            };
            gltfObject["extensionsUsed"] = new List<object>
        {
            voyageExporterExtensionName,
            shaderMotionGltfExtensionName
        };
            gltfObject["extensionsRequired"] = new List<object>
        {
            voyageExporterExtensionName,
            shaderMotionGltfExtensionName
        };

            gltfObject["buffers"] = buffers;
            gltfObject["bufferViews"] = bufferViews;
            gltfObject["accessors"] = accessors;
            gltfObject["meshes"] = meshes;
            gltfObject["materials"] = materials;
            gltfObject["textures"] = textures;
            gltfObject["images"] = images;
            gltfObject["nodes"] = nodes;
            gltfObject["scenes"] = scenes;

            // Add materials, textures, and images
            var materialIndices = new List<int>();
            foreach (var material in meshRenderer.sharedMaterials)
            {
                if (material != null)
                {
                    int materialIndex = AddMaterial(materials, textures, images, binaryData, bufferViews, material);
                    materialIndices.Add(materialIndex);
                }
                else
                {
                    materialIndices.Add(0); // Default material
                }
            }

            // Create mesh
            var gltfMesh = new Dictionary<string, object>
            {
                ["name"] = mesh.name
            };

            AddMeshDataToGltf(gltfMesh, mesh, materialIndices, ref binaryData, bufferViews, accessors);

            int meshIndex = meshes.Count;
            meshes.Add(gltfMesh);

            // Create node with transform
            var transform = meshRenderer.transform;
            var newNode = new Dictionary<string, object>
            {
                ["name"] = transform.name,
                ["mesh"] = meshIndex,
                ["matrix"] = new float[]
                {
                transform.localToWorldMatrix.m00, transform.localToWorldMatrix.m10, transform.localToWorldMatrix.m20, transform.localToWorldMatrix.m30,
                transform.localToWorldMatrix.m01, transform.localToWorldMatrix.m11, transform.localToWorldMatrix.m21, transform.localToWorldMatrix.m31,
                transform.localToWorldMatrix.m02, transform.localToWorldMatrix.m12, transform.localToWorldMatrix.m22, transform.localToWorldMatrix.m32,
                transform.localToWorldMatrix.m03, transform.localToWorldMatrix.m13, transform.localToWorldMatrix.m23, transform.localToWorldMatrix.m33
                }
            };

            int nodeIndex = nodes.Count;
            nodes.Add(newNode);

            // Create new scene with only the new node
            var newScene = new Dictionary<string, object>
            {
                ["nodes"] = new List<object> { nodeIndex },
                ["name"] = "ShaderMotionScene"
            };
            int sceneIndex = scenes.Count;
            scenes.Add(newScene);
            gltfObject["scene"] = sceneIndex;


            // Update buffer size
            if (buffers.Count > 0)
            {
                var buffer = (Dictionary<string, object>)buffers[0];
                buffer["byteLength"] = binaryData.Count;
            }
            else
            {
                buffers.Add(new Dictionary<string, object>
                {
                    ["byteLength"] = binaryData.Count
                });
            }

            return sceneIndex;
        }

        static private void AddMeshDataToGltf(
            Dictionary<string, object> gltfMesh, Mesh mesh, List<int> materialsIndices,
            ref List<byte> binaryData, List<object> bufferViews, List<object> accessors)
        {
            Vector3[] vertices = mesh.vertices;
            Vector3[] normals = mesh.normals;

            int nVertices = vertices.Length;
            List<Vector4> uv0 = new List<Vector4>(nVertices);
            List<Vector4> uv1 = new List<Vector4>(nVertices);
            mesh.GetUVs(0, uv0);
            mesh.GetUVs(1, uv1);

            Vector3 invertOnX = new Vector3(-1, 1, 1);

            for (int v = 0; v < nVertices; v++)
            {


                Vector3 vertex = vertices[v];
                vertex.Scale(invertOnX);
                vertices[v] = vertex;

                Vector3 normal = normals[v];
                normal.Scale(invertOnX);
                normals[v] = normal;

            }

            AddedBuffer positionBufferView = AddVertexDataToBuffer(binaryData, bufferViews, vertices.AsFloat(), 0);
            AddedBuffer normalBufferView = AddVertexDataToBuffer(binaryData, bufferViews, normals.AsFloat(), 0);
            AddedBuffer uv0BufferView = AddVertexDataToBuffer(binaryData, bufferViews, uv0.ToArray().AsFloat(), 0);
            AddedBuffer uv1BufferView = AddVertexDataToBuffer(binaryData, bufferViews, uv1.ToArray().AsFloat(), 0);
            int vector4Size = sizeof(float) * 4;
            int uv0StridedBufferViewIndex = AddAnotherViewTo(uv0BufferView, bufferViews, vector4Size);

            int positionAccessorIndex = CreateAccessor(accessors, positionBufferView.index, 0, GLTF_FLOAT_FORMAT, nVertices, "VEC3", GetMinMax3(vertices));
            int normalAccessorIndex = CreateAccessor(accessors, normalBufferView.index, 0, GLTF_FLOAT_FORMAT, nVertices, "VEC3", null);
            int uv0AccessorIndex = CreateAccessor(accessors, uv0BufferView.index, 0, GLTF_FLOAT_FORMAT, nVertices, "VEC4", null);
            int uv1AccessorIndex = CreateAccessor(accessors, uv1BufferView.index, 0, GLTF_FLOAT_FORMAT, nVertices, "VEC4", null);
            int uv0StridedIndex = CreateAccessor(accessors, uv0StridedBufferViewIndex, 0, GLTF_FLOAT_FORMAT, nVertices, "VEC2", null);

            int subMeshCount = mesh.subMeshCount;
            List<object> allPrimitives = new List<object>(subMeshCount);
            for (int subMeshI = 0; subMeshI < subMeshCount; subMeshI++)
            {
                int baseVertex = mesh.GetSubMesh(subMeshI).baseVertex;

                int[] subMeshTriangles = mesh.GetTriangles(subMeshI);
                int nTrianglesIndices = subMeshTriangles.Length;
                for (int a = 0; a < nTrianglesIndices; a += 3)
                {
                    int b = a + 1;
                    int c = a + 2;

                    int pointB = subMeshTriangles[a + 1];
                    int pointC = subMeshTriangles[a + 2];

                    subMeshTriangles[c] = pointB;
                    subMeshTriangles[b] = pointC;
                }

                int indicesBufferViewIndex = AddIndicesDataToBuffer(binaryData, bufferViews, subMeshTriangles);
                int indicesAccessorIndex = CreateAccessor(accessors, indicesBufferViewIndex, 0, 5123, subMeshTriangles.Length, "SCALAR", null);

                Dictionary<string, object> subMeshPrimitives = new Dictionary<string, object>
                {
                    ["attributes"] = new Dictionary<string, object>
                    {
                        ["POSITION"] = positionAccessorIndex,
                        ["NORMAL"] = normalAccessorIndex,
                        ["_TEXCOORD_4D_0"] = uv0AccessorIndex,
                        ["_TEXCOORD_4D_1"] = uv1AccessorIndex,
                        ["TEXCOORD_0"] = uv0StridedIndex,
                    },
                    ["indices"] = indicesAccessorIndex,
                    ["material"] = materialsIndices.Count > subMeshI ? materialsIndices[subMeshI] : 0
                };
                allPrimitives.Add(subMeshPrimitives);
            }
            gltfMesh["primitives"] = allPrimitives;
        }

        static private AddedBuffer AddVertexDataToBuffer(List<byte> binaryData, List<object> bufferViews, float[][] floats, int byteStride)
        {
            int byteOffset = binaryData.Count;
            int byteLength = floats.Length * floats[0].Length * sizeof(float);
            int realignedByteStride = byteStride / sizeof(float) * sizeof(float); // Realigned on 4 bytes boundary
            int actualByteStride = realignedByteStride <= byteLength ? byteLength : byteStride;

            foreach (float[] floatArray in floats)
            {
                foreach (float floatValue in floatArray)
                {
                    binaryData.AddRange(BitConverter.GetBytes(floatValue));
                }
            }

            Dictionary<string, object> bufferView = new Dictionary<string, object>
            {
                ["buffer"] = 0,
                ["byteOffset"] = byteOffset,
                ["byteLength"] = byteLength,
                ["byteStride"] = byteStride,
                ["target"] = GLTF_ARRAY_BUFFER
            };

            int index = bufferViews.Count;
            bufferViews.Add(bufferView);
            return new AddedBuffer { index = index, byteOffset = byteOffset, byteLength = byteLength };
        }

        static private int AddAnotherViewTo(AddedBuffer buffer, List<object> bufferViews, int stride)
        {
            Dictionary<string, object> bufferView = new Dictionary<string, object>
            {
                ["buffer"] = 0,
                ["byteOffset"] = buffer.byteOffset,
                ["byteLength"] = buffer.byteLength,
                ["byteStride"] = stride,
                ["target"] = GLTF_ARRAY_BUFFER
            };
            int index = bufferViews.Count;
            bufferViews.Add(bufferView);
            return index;
        }

        static private int AddIndicesDataToBuffer(List<byte> binaryData, List<object> bufferViews, int[] triangles)
        {
            int byteOffset = binaryData.Count;
            int byteLength = triangles.Length * sizeof(ushort);

            foreach (var index in triangles)
            {
                binaryData.AddRange(BitConverter.GetBytes((ushort)index));
            }

            var bufferView = new Dictionary<string, object>
            {
                ["buffer"] = 0,
                ["byteOffset"] = byteOffset,
                ["byteLength"] = byteLength,
                ["target"] = GLTF_ELEMENT_ARRAY_BUFFER
            };

            int bufferViewIndex = bufferViews.Count;
            bufferViews.Add(bufferView);
            return bufferViewIndex;
        }

        static private int CreateAccessor(List<object> accessors, int bufferViewIndex, int byteOffset, int componentType, int count, string type, Dictionary<string, object> minMax)
        {
            var accessor = new Dictionary<string, object>
            {
                ["bufferView"] = bufferViewIndex,
                ["byteOffset"] = byteOffset,
                ["componentType"] = componentType,
                ["count"] = count,
                ["type"] = type
            };

            if (minMax != null)
            {
                if (minMax.ContainsKey("min")) accessor["min"] = minMax["min"];
                if (minMax.ContainsKey("max")) accessor["max"] = minMax["max"];
            }

            int index = accessors.Count;
            accessors.Add(accessor);
            return index;
        }

        static private Dictionary<string, object> GetMinMax3(Vector3[] vertices, int from = 0, int to = -1)
        {
            to = to != -1 ? to : vertices.Length;
            if (vertices.Length <= from || vertices.Length < to) return null;

            Vector3 min = vertices[from];
            Vector3 max = vertices[from];

            for (int i = from; i < to; i++)
            {
                Vector3 vertex = vertices[i];
                min = Vector3.Min(min, vertex);
                max = Vector3.Max(max, vertex);
            }

            return new Dictionary<string, object>
            {
                ["min"] = new float[] { min.x, min.y, min.z },
                ["max"] = new float[] { max.x, max.y, max.z }
            };
        }

        static bool IsShaderMotionMaterial(Material material)
        {
            return material.shader.name.EndsWith("MeshPlayer");
        }

        static bool IsMtoon10Material(Material material)
        {
            return material.shader.name.Contains("MToon10");
        }


        static void StoreShaderProperties(GltfToShaderProperty[] properties, Material material, Dictionary<string, object> gltfMaterialInfo, GltfContext context)
        {
            foreach (var property in properties)
            {
                string shaderProperty = property.unityName;
                string gltfName = property.gltfName;
                switch (property.valueType)
                {
                    case ShaderVarType.Texture:
                        {
                            Texture2D tex2d = material.GetTexture(shaderProperty) as Texture2D;
                            if (tex2d == null)
                            {
                                continue;
                            }
                            gltfMaterialInfo[gltfName] = AddTextureToGltf(tex2d, context);
                        }
                        break;
                    case ShaderVarType.Color:
                        {
                            Color color = material.GetColor(shaderProperty);
                            gltfMaterialInfo[gltfName] = new float[] { color.r, color.g, color.b, color.a };
                        }
                        break;
                    case ShaderVarType.Float:
                        {
                            float value = material.GetFloat(shaderProperty);
                            gltfMaterialInfo[gltfName] = value;
                        }
                        break;
                    case ShaderVarType.Bool:
                        {
                            float value = material.GetFloat(shaderProperty);
                            gltfMaterialInfo[gltfName] = (value != 0f);
                        }
                        break;
                    case ShaderVarType.FloatEnum:
                        {
                            string[] acceptableValues = property.enumValues;
                            if (acceptableValues == null) { continue; }
                            int nameIndex = (int)material.GetFloat(shaderProperty);
                            if (nameIndex < 0 || nameIndex >= acceptableValues.Length) { continue; }

                            gltfMaterialInfo[gltfName] = acceptableValues[nameIndex];
                        }
                        break;
                    case ShaderVarType.Int:
                        {
                            float value = material.GetFloat(shaderProperty);
                            gltfMaterialInfo[gltfName] = (int)value;
                        }
                        break;
                }
            }
        }

        static void EncodeAsMaterialExtension(
            string extensionName,
            GltfToShaderProperty[] properties,
            Dictionary<string, object> gltfMaterial,
            Material unityMaterial,
            GltfContext context)
        {
            Dictionary<string, object> extensions = gltfMaterial["extensions"] as Dictionary<string, object>;
            Dictionary<string, object> extension = new Dictionary<string, object>();
            StoreShaderProperties(properties, unityMaterial, extension, context);
            extensions[extensionName] = extension;
        }



        static Dictionary<string, object> AddTextureToGltf(
            Texture2D texture,
            GltfContext context)
        {
            int imageIndex = AddTextureToImages(context, texture);
            int textureIndex = AddTextureReference(context, imageIndex);

            return new Dictionary<string, object>
            {
                ["index"] = textureIndex,
                ["texCoord"] = 0
            };
        }

        static private int AddMaterial(List<object> materials, List<object> textures, List<object> images, List<byte> binaryData, List<object> bufferViews, Material unityMaterial)
        {
            var gltfMaterialPbrProperty = new Dictionary<string, object>
            {
                ["baseColorFactor"] = new float[] { 1.0f, 1.0f, 1.0f, 1.0f },
                ["metallicFactor"] = 0.0f,
                ["roughnessFactor"] = 1.0f
            };
            var gltfMaterial = new Dictionary<string, object>
            {
                ["name"] = unityMaterial.name,
                ["extensions"] = new Dictionary<string, object>(),
                ["pbrMetallicRoughness"] = gltfMaterialPbrProperty
            };

            GltfContext context = new GltfContext
            {
                textures = textures,
                images = images,
                binaryData = binaryData,
                bufferViews = bufferViews
            };

            StoreShaderProperties(standardProperties, unityMaterial, gltfMaterial, context);
            StoreShaderProperties(standardPbrProperties, unityMaterial, gltfMaterialPbrProperty, context);

            if (IsShaderMotionMaterial(unityMaterial))
            {
                EncodeAsMaterialExtension(
                    shaderMotionGltfExtensionName,
                    shaderMotionProperties,
                    gltfMaterial,
                    unityMaterial,
                    context);
            }

            if (IsMtoon10Material(unityMaterial))
            {
                EncodeAsMaterialExtension(
                    vrmcMtoonExtensionName,
                    mToonProperties,
                    gltfMaterial,
                    unityMaterial,
                    context);
            }

            int materialIndex = materials.Count;
            materials.Add(gltfMaterial);
            return materialIndex;
        }

        static private int AddTextureToImages(GltfContext context, Texture2D texture)
        {
            byte[] pngData;

            string mimetype;
            Dictionary<string, object> extension = new Dictionary<string, object>();
            Debug.Log($"Texture : {texture.name} {texture.width} x {texture.height} - {texture.format} / {texture.graphicsFormat} (SRGB : {texture.isDataSRGB}");
            
            if (texture.format == TextureFormat.RGBAFloat)
            {
                Debug.Log("As RGBAFloat");
                pngData = texture.GetRawTextureData();
                mimetype = "image/raw";

                extension["EXT_voyage_exporter"] = new Dictionary<string, object>()
                {
                    ["width"] = texture.width,
                    ["height"] = texture.height,
                    ["format"] = "RGBAFloat",
                    ["linear"] = !texture.isDataSRGB
                };

            }
            else if ((texture.width * texture.height) < (64*64) && texture.format == TextureFormat.ARGB32)
            {
                Debug.Log("As ARGB32");
                pngData = texture.GetRawTextureData();
                mimetype = "image/raw";

                extension["EXT_voyage_exporter"] = new Dictionary<string, object>()
                {
                    ["width"] = texture.width,
                    ["height"] = texture.height,
                    ["format"] = "ARGB8",
                    ["linear"] = !texture.isDataSRGB
                };
            }
            else
            {
                Debug.Log("As DXT5Crunched");
                Texture2D compressedTexture = new Texture2D(texture.width, texture.height);
                compressedTexture.SetPixels(texture.GetPixels());
                compressedTexture.Apply();
                EditorUtility.CompressTexture(
                    compressedTexture,
                    TextureFormat.DXT5Crunched, TextureCompressionQuality.Best);


                //Texture2D invertedTexture = InvertTextureY(texture);
                // Convert texture to PNG bytes
                pngData = compressedTexture.GetRawTextureData();

                mimetype = "image/raw";
                extension["EXT_voyage_exporter"] = new Dictionary<string, object>()
                {
                    ["width"] = compressedTexture.width,
                    ["height"] = compressedTexture.height,
                    ["format"] = "DXT5Crunched",
                    ["linear"] = !texture.isDataSRGB
                };
            }


            int byteOffset = context.binaryData.Count;
            context.binaryData.AddRange(pngData);

            var bufferView = new Dictionary<string, object>
            {
                ["buffer"] = 0,
                ["byteOffset"] = byteOffset,
                ["byteLength"] = pngData.Length
            };

            int bufferViewIndex = context.bufferViews.Count;
            context.bufferViews.Add(bufferView);

            var image = new Dictionary<string, object>
            {
                ["name"] = texture.name,
                ["bufferView"] = bufferViewIndex,
                ["mimeType"] = mimetype
            };
            if (extension.Count > 0)
            {
                image["extensions"] = extension;
            }

            int imageIndex = context.images.Count;
            context.images.Add(image);
            return imageIndex;
        }

        static private int AddTextureReference(GltfContext context, int imageIndex)
        {
            var texture = new Dictionary<string, object>
            {
                ["source"] = imageIndex,
                ["sampler"] = 0 // Assume default sampler exists or will be created
            };

            int textureIndex = context.textures.Count;
            context.textures.Add(texture);
            return textureIndex;
        }

        static private void WriteGLB(string filePath, Dictionary<string, object> gltfDict, List<byte> binaryData)
        {
            string jsonString = new JsonSerializer().Serialize(gltfDict);
            byte[] jsonBytes = Encoding.UTF8.GetBytes(jsonString);
            const uint glbHeaderSize = 12;
            const uint glbSectionHeaderSize = 8;

            // Pad JSON to 4-byte alignment
            while (jsonBytes.Length % 4 != 0)
            {
                Array.Resize(ref jsonBytes, jsonBytes.Length + 1);
                jsonBytes[jsonBytes.Length - 1] = 0x20; // Space character
            }

            // Pad binary data to 4-byte alignment
            while (binaryData.Count % 4 != 0)
            {
                binaryData.Add(0);
            }

            uint totalLength =
                glbHeaderSize
                + glbSectionHeaderSize
                + (uint)jsonBytes.Length
                + glbSectionHeaderSize
                + (uint)binaryData.Count;

            using (var writer = new BinaryWriter(File.Create(filePath)))
            {
                // GLB Header
                writer.Write(GLTF_HEADER_MAGIC); // "glTF"
                writer.Write(2u);           // version
                writer.Write(totalLength);  // total length

                // JSON chunk
                writer.Write((uint)jsonBytes.Length);
                writer.Write(GLTF_JSON_SECTION_HEADER_MAGIC); // "JSON"
                writer.Write(jsonBytes);

                // Binary chunk
                writer.Write((uint)binaryData.Count);
                writer.Write(GLTF_BIN_SECTION_HEADER_MAGIC); // "BIN\0"
                writer.Write(binaryData.ToArray());
            }
        }

    }
}
#endif